import { nanoid, customAlphabet } from 'nanoid';
import { createTinyUrl, findTinyUrl } from './urlService';
import type { tinyUrl } from './urlService';

/**
 * Return unique nano id generated by nanoid package
 * @param url 
 * @param baseRoute 
 * @param customText 
 * @param size 
 */
async function getUniqNanoId(url: string, baseRoute: string, customText?: string, size?: number): Promise<string> {
  let hashedValue;
  do {
    if (customText) {
      const customizedNanoid = customAlphabet(customText, size ?? 10);
      hashedValue = await customizedNanoid();
    } else {
      hashedValue = await nanoid();
    }
    const tinyUrl: tinyUrl = await findTinyUrl(hashedValue);
    if (!tinyUrl) break;
  } while (true);
  return hashedValue;
}

/**
 * Return original url if found, return {} otherwise
 * @param hashedValue 
 */
export async function getOriginalUrl(hashedValue: string): Promise<tinyUrl | null> {
  const response: tinyUrl = await findTinyUrl(hashedValue);
  return response ?? {};
}

/**
 * Saved hashed url depending on whether it is a customized nanoid or regular nanoid,
 * return once completed
 * @param url 
 * @param baseRoute 
 * @param customText 
 * @param size 
 */
export async function saveHashedUrl(url: string, baseRoute: string, customText?: string, size?: number): Promise<tinyUrl> {
  const hashedValue: string = await getUniqNanoId(url, baseRoute, customText, size);
  const isUrlCreated: boolean = await createTinyUrl(hashedValue, url);
  const response: tinyUrl = isUrlCreated ? await findTinyUrl(hashedValue) : null;
  return {
    hashedValues: response?.hashedValues,
    originalURL: response?.originalURL,
    creationDate: response?.creationDate,
    expirationDate: response?.expirationDate,
    baseRoute: `${baseRoute}/${response?.hashedValues}`
  }
}
